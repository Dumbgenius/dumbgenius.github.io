<!DOCTYPE html>
<html>
<head>
	<title>Procedural Maze Generation</title>
	<link rel="stylesheet" href="style.css">
</head>

<body>
		<div id=header>
			<h1>Procedural Generation using ~~science~~</h1>
		</div>
		<div id=canvas>
			<canvas width=500 height=500 id="mainCanvas"></canvas>
		</div>
		<div id=config>
		<input type=text id="seed"> <button id="randomSeed">Random seed!</button>
		<br><input type=range id="size" min=5 max=50 value=10> Size: <span id="sizeOut"></span>
		<br><input type=range id="randomProbability" min=0 max=100 value=20> Probability of random: <span id="randomProbabilityOut"></span>
		<br>
		<br><input type=checkbox id="autoGenerate" checked>Regenerate on settings change
		<br><input type=checkbox id="autoPathfind">Pathfind on settings change
		<br><button id = "generateAtOnceButton">Generate all at once</button>
		<br><button id = "generateStepwiseButton">Generate bit-by-bit</button>
		<br><button id = "pathfindAtOnceButton">Pathfind all at once</button>
		<br><button id = "pathfindStepwiseButton">Pathfind bit-by-bit</button>
		<br><input type=range id="ups" min=1 max=60 value=30> Target updates per second: <span id="upsOut"></span>
		<br>
		<br>Stats: <span id=statsOut></span> 
		<br>
		<br>
		</div>
		<div id=info>
			Mazes are generated by the Growing Tree algorithm, which works as follows:<br>
			<ol>
				<li>Pick a random cell to start at. Add it to the list of selected cells.</li>
				<li>Pick a cell from the list of selected cells.</li>
				<li>If the chosen cell has no unvisited neighbours, remove it from the list of selected cells.</li>
				<li>If the chosen cell has unvisited neighbours, pick an unvisited neighbour at random, remove the wall between the two cells, and add the neighbour to the list of selected cells.</li>
				<li>Repeat steps 2-4 until the list of selected cells is empty.</li>
			</ol>
			The key to the Growing Tree algorithm is the method by which we pick a cell in step 2. If we pick the most recently added cell, the algorithm behaves identically to a randomised depth-first search or recursive backtracker algorithm. If a cell is chosen at random, the algorithm behaves identically to Prim's algorithm. <br>
			<br>
			By deciding at random whether to pick the most recent cell or a random cell, we achieve a middle ground between the long and winding corridoors of a recursive backtracker and the chaotic branching of Prim's algorithm. You can change the probability of choosing a cell at random as opposed to the most recent cell with the slider above. <br>
			<br>
			When generating bit-by-bit, grey cells are unvisited, pink cells are on the list of selected cells, white cells are visited and not on the list, and the red cell is the most recently modified cell.<br>
			<br>
			Pathfinding is done via a simple depth-first search algorithm. Due to the way the maze is generated, loops are impossible, and so there is only ever one possible route from a given point A to point B, which means that the normal weakness of a depth-first search (the fact that it tends to find unnecessarily long routes) is not an issue.
		</div>
	<center>
	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.3.10/seedrandom.min.js"></script>
	<script src="mazegen.js"></script>
</body>
</html>